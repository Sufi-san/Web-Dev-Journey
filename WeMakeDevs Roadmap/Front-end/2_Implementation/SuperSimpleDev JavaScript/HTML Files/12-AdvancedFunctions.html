<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Functions Part 1 & 2</title>
</head>
<body>
    <button class="js-btn">Click</button>
    <script>
        /*
        const clickBtn = document.querySelector('.js-btn');

        const clickEvent = () => {
            console.log('click');
        };

        // Every HTML element has 'addEventListener()' which is a better way to add functionality than 'onclick'
        // It has 2 paramters, first one defines type of event to detect and other paramter is the event that we want to run
        // It lets us add multiple eventListeners
        // We can also remove eventListeners
        clickBtn.addEventListener('click', clickEvent);

        clickBtn.addEventListener('click', () => {
            console.log('click2');
        });

        // Removing Event Listeners:
        clickBtn.removeEventListener('click', clickEvent);
        // Because of these advantages, it is best practice to use 'addEventListener' instead of 'onclick' attribute. */

        /*// Basic function
        function greeting() {
            console.log('hello');
        }
        greeting();
        /* The above code is a shortcut for:
            var greeting = function() {
                console.log('hello');
            }
        */
        // This provides us with the 'hoisting' property which allows us to neglect the order of function declaration and calling*/

        /*// Here we will learn of functions as values...
        // We can save a function inside a variable !
        // These however, do not support hoisting
        // function1(); , in this line, will give error
        const function1 = function() {
            console.log('hello2');
        };
        // The above function with no name, is an anonymous function
        console.log(function1);
        console.log(typeof function1);
        function1();

        // What else can we do with values?
        // Saving in objects
        const object1 = {
            num: 2,
            fun: function() {
                console.log('hello3');
            }
        };
        object1.fun();

        // Passing to other functions
        function display(param) {
            console.log(param);
        }
        display(2);
        function run(param) {
            param();
        }
        run(function() {
            console.log('hello4');
        });
        // The function that we are passing in is a 'callback' function*/

        /*// Practical usage:
        // The setTimeout() is a built-in function:
        setTimeout(function() {
            console.log('timeout');
        }, 3000);
        // We can pass a function and a count (1sec == 1000) and the function is called after the given period of time

        // Asynchronous code:
        console.log('next line');
        // JS does not wait for setTimeout() to finish, it immediately move forward to next line, this is known as Asynchronous code.

        // setInterval() is another built-in function
        setInterval(function() {
            console.log('interval');
        }, 3000);
        console.log('nextline2');
        // The difference here is that the code will keep running after a certain period of time, it is like setTimeout() on loop*/

        /*// Another way to loop through an Array:
        [
            'make dinner',
            'wash dishes',
            'watch youtube'
        ].forEach(function(value, index) {
            if(value === 'wash dishes') return;
            console.log(index);
            console.log(value);
        });
        // It is the preferred way to loop through an array and it is easier to read than a simple for loop
        // Instead of using a 'continue' to skip loop we use the 'return' statement instead in a forEach loop
        // There is no alternative to 'break' statement so in that case it is better to use normal for loop

        // Shorter Way to write functions: (Arrow functions)
        const arrowFunction = (param, param2) => {
            console.log('hello');
            return 5;
        };
        arrowFunction(); // mostly work the same way as regular functions

        // The above function can be written as:
        const regularFunction = function(param, param2) {
            console.log('hello');
            return 5;
        };
        regularFunction();

        // Arrow functions have a few shortcuts that regular functions do not have
        const oneParam = param => {
            console.log(param + 1);
        }
        oneParam(5); // we can remove round brackets if function has only one param

        const oneLine = () => 2 + 3;
        // When there is only one line we can eliminate 'return' keyword and '{}' curly brackets
        console.log(oneLine());

        // Practice for Arrow function:
        [
            'make dinner',
            'wash dishes',
            'watch youtube'
        ].forEach((value, index) => {
            if(value === 'wash dishes') return;
            console.log(index);
            console.log(value);
        });

        // As objects already have a shorthand method to contan function, it is recommended to use that instead of arrow functions
        const object2 = {
            method: () => {

            },
            method() {

            }
        };*/

        // Two more Array Methods:

        // 1. filter();
        // it is similar to forEach however, this one returns a value.
        const newArr = [1, -3, 5].filter((value, index) => {
            return value >= 0;
        });
        console.log(newArr);
        // What it does is that, it creates a new Array, if the end value for iteration is true it will put it inside new array
        // If false, the element is skipped and not included in new array
        // By default, filter will return 'false'

        // 2. map();
        // This too works like forEach and filter
        const newArr2 = [1, 1, 3].map((value) => {
            return value * 2;
        });
        console.log(newArr2);
        // Map too creates a new array and whatever is returned inside the function will be included in that array

        // Making the code compact using arrow function shortcuts
        const newArr3 = [1, 1, 3].map(value => value * 2);
        console.log(newArr3);

        // Closure: If function has access to value, it will always have access to that value
    </script>
</body>
</html>